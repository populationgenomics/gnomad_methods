<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.annotations &mdash; gnomad master documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/broadinstitute/gnomad_methods/releases">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gnomad.utils.annotations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.annotations</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">hail.utils.misc</span> <span class="kn">import</span> <span class="n">new_temp_file</span>

<span class="kn">import</span> <span class="nn">gnomad.utils.filtering</span> <span class="k">as</span> <span class="nn">filter_utils</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.gen_stats</span> <span class="kn">import</span> <span class="n">to_phred</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">ANNOTATIONS_HISTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;FS&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,20)</span>
    <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;RAW_MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span>
    <span class="s2">&quot;MQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;QD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;SOR&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;BaseQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;ClippingRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;DP&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,8)</span>
    <span class="s2">&quot;VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (-20,20)</span>
    <span class="s2">&quot;AS_VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;rf_tp_probability&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;pab_max&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">VRS_CHROM_IDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;GRCh38&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;chr1&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Ya6Rs7DHhDeg7YaOSg1EoNi3U_nQ9SvO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr2&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.pnAqCRBrTsUoBghSD1yp_jXWSmlbdh4g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr3&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Zu7h9AggXxhTaGVsy7h_EZSChSZGcmgX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr4&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.HxuclGHh0XCDuF8x6yQrpHUBL7ZntAHc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr5&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.aUiQCzCPZ2d0csHbMSbh2NzInhonSXwI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr6&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.0iKlIQk2oZLoeOG9P1riRU6hvL5Ux8TV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr7&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.F-LrLMe1SRpfUZHkQmvkVKFEGaoDeHul&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr8&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.209Z7zJ-mFypBEWLk4rNC6S_OxY5p7bs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr9&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.KEO-4XBcm1cxeo_DIQ8_ofqGUkp4iZhI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr10&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.ss8r_wB0-b9r44TQTMmVTI92884QvBiB&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr11&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.2NkFm8HK88MqeNkCgj78KidCAXgnsfV1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr12&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.6wlJpONE3oNb4D69ULmEXhqyDZ4vwNfl&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr13&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ._0wi-qoDrvram155UmcSC-zA5ZK4fpLT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr14&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.eK4D2MosgK_ivBkgi6FVPg5UXs1bYESm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr15&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.AsXvWL1-2i5U_buw6_niVIxD6zTbAuS6&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr16&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.yC_0RBj3fgBlvgyAuycbzdubtLxq-rE0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr17&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.dLZ15tNO1Ur0IcGjwc3Sdi_0A6Yf4zm7&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr18&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.vWwFhJ5lQDMhh-czg06YtlWqu0lvFAZV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr19&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.IIB53T8CNeJJdUqzn9V_JnRtQadwWCbl&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr20&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.-A1QmD_MatoqxvgVxBLZTONHz9-c7nQo&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr21&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.5ZUqxCmDDgN4xTRbaSjN8LwgZironmB8&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr22&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.7B7SHsmchAR0dFcDCuSFjJAo7tX87krQ&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chrX&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.w0WZEvgJF0zf_P4yyTzjjv9oW1z61HHP&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chrY&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.8_liLu1aycC0tPQPFmUaGXJLDs5SbPZ5&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;GRCh37&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.S_KjnFVz-FE7M0W6yoaUDgYxLPc1jyWU&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.9KdcA9ZpY1Cpvxvg8bMSLYDUpsX6GDLO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.VNBualIltAyi2AI_uXcKU7M9XUOuA7MS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;4&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.iy7Zfceb5_VGtTQzJ-v5JpPbpeifHD_V&quot;</span><span class="p">,</span>
        <span class="s2">&quot;5&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.vbjOdMfHJvTjK_nqvFvpaSKhZillW0SX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;6&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.KqaUhJMW3CDjhoVtBetdEKT1n6hM-7Ek&quot;</span><span class="p">,</span>
        <span class="s2">&quot;7&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.IW78mgV5Cqf6M24hy52hPjyyo5tCCd86&quot;</span><span class="p">,</span>
        <span class="s2">&quot;8&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.tTm7wmhz0G4lpt8wPspcNkAD_qiminj6&quot;</span><span class="p">,</span>
        <span class="s2">&quot;9&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.HBckYGQ4wYG9APHLpjoQ9UUe9v7NxExt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.-BOZ8Esn8J88qDwNiSEwUr5425UXdiGX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.XXi2_O1ly-CCOi3HP5TypAw7LtC6niFG&quot;</span><span class="p">,</span>
        <span class="s2">&quot;12&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.105bBysLoDFQHhajooTAUyUkNiZ8LJEH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;13&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Ewb9qlgTqN6e_XQiRVYpoUfZJHXeiUfH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;14&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.5Ji6FGEKfejK1U6BMScqrdKJK8GqmIGf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;15&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.zIMZb3Ft7RdWa5XYq0PxIlezLY2ccCgt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;16&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.W6wLoIFOn4G7cjopxPxYNk2lcEqhLQFb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;17&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.AjWXsI7AkTK35XW9pgd3UbjpC3MAevlz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;18&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.BTj4BDaaHYoPhD3oY2GdwC_l0uqZ92UD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;19&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.ItRDD47aMoioDCNW_occY5fWKZBKlxCX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;20&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.iy_UbUrvECxFRX5LPTH_KPojdlT7BKsf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;21&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.LpTaNW-hwuY_yARP0rtarCnpCQLkgVCg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;22&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.XOgHwwR3Upfp5sZYk6ZKzvV25a4RBVu8&quot;</span><span class="p">,</span>
        <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.v7noePfnNpK8ghYXEqZ9NukMXW7YeNsm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.BT7QyW5iXaX_1PSX-msSGYsqRdMKqkj-&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>


<div class="viewcode-block" id="pop_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.pop_max_expr">[docs]</a><span class="k">def</span> <span class="nf">pop_max_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pop_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pop&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Create an expression containing the frequency information about the population that has the highest AF in `freq_meta`.</span>

<span class="sd">    Populations specified in `pops_to_exclude` are excluded and only frequencies from adj populations are considered.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - pop: str</span>

<span class="sd">    :param freq: ArrayExpression of Structs with fields [&#39;AC&#39;, &#39;AF&#39;, &#39;AN&#39;, &#39;homozygote_count&#39;]</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (as returned by annotate_freq)</span>
<span class="sd">    :param pops_to_exclude: Set of populations to skip for popmax calcluation</span>
<span class="sd">    :param pop_label: Label of the population field in the meta dictionary</span>
<span class="sd">    :return: Popmax struct</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pops_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">popmax_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pop_label</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">freq_filtered</span> <span class="o">=</span> <span class="n">popmax_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">pop_label</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pop_label</span><span class="p">]})</span>
    <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">freq_filtered</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="project_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.project_max_expr">[docs]</a><span class="k">def</span> <span class="nf">project_max_expr</span><span class="p">(</span>
    <span class="n">project_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">alleles_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">n_projects</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an expression that computes allele frequency information by project for the `n_projects` with the largest AF at this row.</span>

<span class="sd">    Will return an array with one element per non-reference allele.</span>

<span class="sd">    Each of these elements is itself an array of structs with the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - project: str</span>

<span class="sd">    .. note::</span>

<span class="sd">        Only projects with AF &gt; 0 are returned.</span>
<span class="sd">        In case of ties, the project ordering is not guaranteed, and at most `n_projects` are returned.</span>

<span class="sd">    :param project_expr: column expression containing the project</span>
<span class="sd">    :param gt_expr: entry expression containing the genotype</span>
<span class="sd">    :param alleles_expr: row expression containing the alleles</span>
<span class="sd">    :param n_projects: Maximum number of projects to return for each row</span>
<span class="sd">    :return: projectmax expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles_expr</span><span class="p">)</span>

    <span class="c1"># compute call stats by  project</span>
    <span class="n">project_cs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">project_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">alleles_expr</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">n_alleles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Exclude monomorphic sites</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_alleles</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
                <span class="n">project_cs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="c1"># filter to projects with AF &gt; 0</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
                <span class="c1"># order the callstats computed by AF in decreasing order</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                <span class="c1"># take the n_projects projects with largest AF</span>
            <span class="p">)[:</span><span class="n">n_projects</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="c1"># add the project in the callstats struct</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="n">AC</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AF</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AN</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span>
                    <span class="n">homozygote_count</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">project</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="faf_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.faf_expr">[docs]</a><span class="k">def</span> <span class="nf">faf_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">faf_thresholds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span>
    <span class="n">pop_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pop&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the filtering allele frequency (FAF) for each threshold specified in `faf_thresholds`.</span>

<span class="sd">    See http://cardiodb.org/allelefrequencyapp/ for more information.</span>

<span class="sd">    The FAF is computed for each of the following population stratification if found in `freq_meta`:</span>

<span class="sd">        - All samples, with adj criteria</span>
<span class="sd">        - For each population, with adj criteria</span>
<span class="sd">        - For all sex/population on the non-PAR regions of sex chromosomes (will be missing on autosomes and PAR regions of sex chromosomes)</span>

<span class="sd">    Each of the FAF entry is a struct with one entry per threshold specified in `faf_thresholds` of type float64.</span>

<span class="sd">    This returns a tuple with two expressions:</span>

<span class="sd">        1. An array of FAF expressions as described above</span>
<span class="sd">        2. An array of dict containing the metadata for each of the array elements, in the same format as that produced by `annotate_freq`.</span>

<span class="sd">    :param freq: ArrayExpression of call stats structs (typically generated by hl.agg.call_stats)</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (typically generated using annotate_freq)</span>
<span class="sd">    :param locus: locus</span>
<span class="sd">    :param pops_to_exclude: Set of populations to exclude from faf calculation (typically bottlenecked or consanguineous populations)</span>
<span class="sd">    :param faf_thresholds: List of FAF thresholds to compute</span>
<span class="sd">    :param pop_label: Label of the population field in the meta dictionary</span>
<span class="sd">    :return: (FAF expression, FAF metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pops_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="n">pop_label</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pop_label</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sex_faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">))</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="n">pop_label</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pop_label</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="n">sex_faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="o">~</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                                <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
                    <span class="p">}</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_meta</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sex_faf_freq_indices</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">faf_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_anc_faf_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.gen_anc_faf_max_expr">[docs]</a><span class="k">def</span> <span class="nf">gen_anc_faf_max_expr</span><span class="p">(</span>
    <span class="n">faf</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">faf_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">pop_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pop&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the maximum FAF and corresponding genetic ancestry for each of the thresholds in `faf`.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - faf95_max: float64</span>
<span class="sd">        - faf95_max_gen_anc: str</span>
<span class="sd">        - faf99_max: float64</span>
<span class="sd">        - faf99_max_gen_anc: str</span>

<span class="sd">    :param faf: ArrayExpression of Structs of FAF thresholds previously computed. When</span>
<span class="sd">        `faf_expr` is used, contains fields &#39;faf95&#39; and &#39;faf99&#39;.</span>
<span class="sd">    :param faf_meta: ArrayExpression of meta dictionaries corresponding to faf (as</span>
<span class="sd">        returned by faf_expr)</span>
<span class="sd">    :param pop_label: Label of the population field in the meta dictionary</span>
<span class="sd">    :return: Genetic ancestry group struct for FAF max</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faf_gen_anc_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">pop_label</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">max_fafs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">()</span>

    <span class="c1"># Iterate through faf thresholds, generally &#39;faf95&#39; and &#39;faf99&#39;, and</span>
    <span class="c1"># take the maximum faf value, &#39;[0]&#39;, and its gen_anc from the sorted faf array</span>
    <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">faf_struct</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
            <span class="n">faf_gen_anc_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                        <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max_gen_anc&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                        <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pop_label</span><span class="p">]</span>
                    <span class="p">),</span>
                <span class="p">}</span>
            <span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">faf</span><span class="p">:</span> <span class="n">faf</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max&quot;</span><span class="p">],</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">max_fafs_expr</span> <span class="o">=</span> <span class="n">max_fafs_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">faf_struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_fafs_expr</span></div>


<div class="viewcode-block" id="qual_hist_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.qual_hist_expr">[docs]</a><span class="k">def</span> <span class="nf">qual_hist_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ab_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">split_adj_and_raw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a struct expression with genotype quality histograms based on the arguments given (dp, gq, ad, ab).</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `gt_expr` is provided, will return histograms for non-reference samples only as well as all samples.</span>
<span class="sd">        - `gt_expr` is required for the allele-balance histogram, as it is only computed on het samples.</span>
<span class="sd">        - If `ab_expr` is provided, the allele-balance histogram is computed using this expression instead of the ad_expr.</span>
<span class="sd">        - If `adj_expr` is provided, additional histograms are computed using only adj samples.</span>

<span class="sd">    :param gt_expr: Entry expression containing genotype.</span>
<span class="sd">    :param gq_expr: Entry expression containing genotype quality.</span>
<span class="sd">    :param dp_expr: Entry expression containing depth.</span>
<span class="sd">    :param ad_expr: Entry expression containing allelic depth (bi-allelic here).</span>
<span class="sd">    :param adj_expr: Entry expression containing adj (high quality) genotype status.</span>
<span class="sd">    :param ab_expr: Entry expression containing allele balance (bi-allelic here).</span>
<span class="sd">    :param split_adj_and_raw: Whether to split the adj and raw histograms into separate fields in the returned struct expr.</span>
<span class="sd">    :return: Genotype quality histograms expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">gq_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;gq_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">gq_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;dp_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dp_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_alt&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span> <span class="n">qual_hist_expr</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">ab_hist_msg</span> <span class="o">=</span> <span class="s2">&quot;Using the </span><span class="si">%s</span><span class="s2"> to compute allele balance histogram...&quot;</span>
        <span class="k">if</span> <span class="n">ab_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">ab_hist_msg</span><span class="p">,</span> <span class="s2">&quot;ab_expr&quot;</span><span class="p">)</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ab_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ad_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">ab_hist_msg</span><span class="p">,</span> <span class="s2">&quot;ad_expr&quot;</span><span class="p">)</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">adj_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adj_qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">qual_hist_name</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">adj_expr</span><span class="p">,</span> <span class="n">qual_hist_expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">split_adj_and_raw</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="n">raw_qual_hists</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">),</span>
                <span class="n">qual_hists</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">adj_qual_hists</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qual_hists</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_adj&quot;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj_qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">)</span></div>


<div class="viewcode-block" id="age_hists_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.age_hists_expr">[docs]</a><span class="k">def</span> <span class="nf">age_hists_expr</span><span class="p">(</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">age_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span>
    <span class="n">lowest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">highest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a StructExpression with the age histograms for hets and homs.</span>

<span class="sd">    :param adj_expr: Entry expression containing whether a genotype is high quality (adj) or not</span>
<span class="sd">    :param gt_expr: Entry expression containing the genotype</span>
<span class="sd">    :param age_expr: Col expression containing the sample&#39;s age</span>
<span class="sd">    :param lowest_boundary: Lowest bin boundary (any younger sample will be binned in n_smaller)</span>
<span class="sd">    :param highest_boundary: Highest bin boundary (any older sample will be binned in n_larger)</span>
<span class="sd">    :param n_bins: Total number of bins</span>
<span class="sd">    :return: A struct with `age_hist_het` and `age_hist_hom`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">age_hist_het</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">age_hist_hom</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_lowqual_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_lowqual_expr">[docs]</a><span class="k">def</span> <span class="nf">get_lowqual_expr</span><span class="p">(</span>
    <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">qual_approx_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">],</span>
    <span class="n">snv_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">snv_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>  <span class="c1"># 1/1000</span>
    <span class="n">indel_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">indel_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>  <span class="c1"># 1/8,000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute lowqual threshold expression for either split or unsplit alleles based on QUALapprox or AS_QUALapprox.</span>

<span class="sd">    .. note::</span>

<span class="sd">        When running This lowqual annotation using QUALapprox, it differs from the GATK LowQual filter.</span>
<span class="sd">        This is because GATK computes this annotation at the site level, which uses the least stringent prior for mixed sites.</span>
<span class="sd">        When run using AS_QUALapprox, this implementation can thus be more stringent for certain alleles at mixed sites.</span>

<span class="sd">    :param alleles: Array of alleles</span>
<span class="sd">    :param qual_approx_expr: QUALapprox or AS_QUALapprox</span>
<span class="sd">    :param snv_phred_threshold: Phred-scaled SNV &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param snv_phred_het_prior: Phred-scaled SNV heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :param indel_phred_threshold: Phred-scaled indel &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param indel_phred_het_prior: Phred-scaled indel heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :return: lowqual expression (BooleanExpression if `qual_approx_expr`is Numeric, Array[BooleanExpression] if `qual_approx_expr` is ArrayNumeric)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_snv_qual</span> <span class="o">=</span> <span class="n">snv_phred_threshold</span> <span class="o">+</span> <span class="n">snv_phred_het_prior</span>
    <span class="n">min_indel_qual</span> <span class="o">=</span> <span class="n">indel_phred_threshold</span> <span class="o">+</span> <span class="n">indel_phred_het_prior</span>
    <span class="n">min_mixed_qual</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_snv_qual</span><span class="p">,</span> <span class="n">min_indel_qual</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qual_approx_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">]),</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_mixed_qual</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_annotations_hists"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_annotations_hists">[docs]</a><span class="k">def</span> <span class="nf">get_annotations_hists</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotations_hists</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
    <span class="n">log10_annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create histograms for variant metrics in ht.info.</span>

<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param ht: Table with variant metrics</span>
<span class="sd">    :param annotations_hists: Dictionary of metrics names and their histogram values (start, end, bins)</span>
<span class="sd">    :param log10_annotations: List of metrics to log scale</span>
<span class="sd">    :return: Dictionary of merics and their histograms</span>
<span class="sd">    :rtype: Dict[str, hl.expr.StructExpression]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check all fields in ht.info and create histograms if they are in</span>
    <span class="c1"># annotations_hists dict</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">log10_annotations</span> <span class="k">else</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">],</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">bins</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">annotations_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">info</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="create_frequency_bins_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.create_frequency_bins_expr">[docs]</a><span class="k">def</span> <span class="nf">create_frequency_bins_expr</span><span class="p">(</span>
    <span class="n">AC</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span> <span class="n">AF</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create bins for frequencies in preparation for aggregating QUAL by frequency bin.</span>

<span class="sd">    Bins:</span>
<span class="sd">        - singleton</span>
<span class="sd">        - doubleton</span>
<span class="sd">        - 0.00005</span>
<span class="sd">        - 0.0001</span>
<span class="sd">        - 0.0002</span>
<span class="sd">        - 0.0005</span>
<span class="sd">        - 0.001,</span>
<span class="sd">        - 0.002</span>
<span class="sd">        - 0.005</span>
<span class="sd">        - 0.01</span>
<span class="sd">        - 0.02</span>
<span class="sd">        - 0.05</span>
<span class="sd">        - 0.1</span>
<span class="sd">        - 0.2</span>
<span class="sd">        - 0.5</span>
<span class="sd">        - 1</span>

<span class="sd">    NOTE: Frequencies should be frequencies from raw data.</span>
<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param AC: Field in input that contains the allele count information</span>
<span class="sd">    :param AF: Field in input that contains the allele frequency information</span>
<span class="sd">    :return: Expression containing bin name</span>
<span class="sd">    :rtype: hl.expr.StringExpression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;binned_singleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;binned_doubleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.00005</span><span class="p">),</span> <span class="s2">&quot;binned_0.00005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.00005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">),</span> <span class="s2">&quot;binned_0.0001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0002</span><span class="p">),</span> <span class="s2">&quot;binned_0.0002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0005</span><span class="p">),</span> <span class="s2">&quot;binned_0.0005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">),</span> <span class="s2">&quot;binned_0.001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.002</span><span class="p">),</span> <span class="s2">&quot;binned_0.002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.005</span><span class="p">),</span> <span class="s2">&quot;binned_0.005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">),</span> <span class="s2">&quot;binned_0.01&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">),</span> <span class="s2">&quot;binned_0.02&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span> <span class="s2">&quot;binned_0.05&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">),</span> <span class="s2">&quot;binned_0.1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">),</span> <span class="s2">&quot;binned_0.2&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s2">&quot;binned_0.5&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;binned_1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">bin_expr</span></div>


<div class="viewcode-block" id="get_adj_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_adj_expr">[docs]</a><span class="k">def</span> <span class="nf">get_adj_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adj genotype annotation.</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">gq_expr</span> <span class="o">&gt;=</span> <span class="n">adj_gq</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">haploid_adj_dp</span><span class="p">,</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_dp</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="o">~</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het_ref</span><span class="p">(),</span> <span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span>
                <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_adj"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_adj">[docs]</a><span class="k">def</span> <span class="nf">annotate_adj</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate genotypes with adj criteria (assumes diploid).</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;GT&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span> <span class="ow">and</span> <span class="s2">&quot;LGT&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No GT field found, using LGT instead.&quot;</span><span class="p">)</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">GT</span>

    <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span> <span class="ow">and</span> <span class="s2">&quot;LAD&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No AD field found, using LAD instead.&quot;</span><span class="p">)</span>
        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">get_adj_expr</span><span class="p">(</span>
            <span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">ad_expr</span><span class="p">,</span> <span class="n">adj_gq</span><span class="p">,</span> <span class="n">adj_dp</span><span class="p">,</span> <span class="n">adj_ab</span><span class="p">,</span> <span class="n">haploid_adj_dp</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="add_variant_type"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_variant_type">[docs]</a><span class="k">def</span> <span class="nf">add_variant_type</span><span class="p">(</span><span class="n">alt_alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get Struct of variant_type and n_alt_alleles from ArrayExpression of Strings.&quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alts</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">non_star_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">alts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">variant_type</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-snv&quot;</span><span class="p">,</span> <span class="s2">&quot;snv&quot;</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-indel&quot;</span><span class="p">,</span> <span class="s2">&quot;indel&quot;</span><span class="p">),</span>
                <span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">),</span>
        <span class="n">n_alt_alleles</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_allele_info"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_allele_info">[docs]</a><span class="k">def</span> <span class="nf">annotate_allele_info</span><span class="p">(</span><span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return bi-allelic sites Table with an &#39;allele_info&#39; annotation.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function requires that the input `ht` is unsplit and returns a split `ht`.</span>

<span class="sd">    &#39;allele_info&#39; is a struct with the following information:</span>
<span class="sd">        - variant_type: Variant type (snv, indel, multi-snv, multi-indel, or mixed).</span>
<span class="sd">        - n_alt_alleles: Total number of alternate alleles observed at variant locus.</span>
<span class="sd">        - has_star: True if the variant contains a star allele.</span>
<span class="sd">        - allele_type: Allele type (snv, insertion, deletion, or mixed).</span>
<span class="sd">        - was_mixed: True if the variant was mixed (i.e. contained both SNVs and indels).</span>
<span class="sd">        - nonsplit_alleles: Array of alleles before splitting.</span>

<span class="sd">    :param Table ht: Unsplit input Table.</span>
<span class="sd">    :return: Split Table with allele data annotation added,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">allele_info</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="n">add_variant_type</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span>
            <span class="n">has_star</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">split_multi</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="n">ref_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alt_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">allele_type_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;snv&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_insertion</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;ins&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_deletion</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;del&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">transmute</span><span class="p">(</span>
        <span class="n">allele_info</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">allele_info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">allele_type</span><span class="o">=</span><span class="n">allele_type_expr</span><span class="p">,</span>
            <span class="n">was_mixed</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">allele_info</span><span class="o">.</span><span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
            <span class="n">nonsplit_alleles</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">old_alleles</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="annotation_type_is_numeric"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_is_numeric">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, return whether it is a numerical type or not.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type is numeric</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">)</span></div>


<div class="viewcode-block" id="annotation_type_in_vcf_info"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_in_vcf_info">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, returns whether that type can be natively exported to a VCF INFO field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Types that aren&#39;t natively exportable to VCF will be converted to String on export.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type can be exported to VCF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tbool</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tset</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bi_allelic_site_inbreeding_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_site_inbreeding_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_site_inbreeding_expr</span><span class="p">(</span>
    <span class="n">call</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">callstats_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the site inbreeding coefficient as an expression to be computed on a MatrixTable.</span>

<span class="sd">    This is implemented based on the GATK InbreedingCoeff metric:</span>
<span class="sd">    https://software.broadinstitute.org/gatk/documentation/article.php?id=8032</span>

<span class="sd">    .. note::</span>

<span class="sd">        The computation is run based on the counts of alternate alleles and thus should only be run on bi-allelic sites.</span>

<span class="sd">    :param call: Expression giving the calls in the MT</span>
<span class="sd">    :param callstats_expr: StructExpression containing only alternate allele AC, AN, and homozygote_count as integers. If passed, used to create expression in place of GT calls.</span>
<span class="sd">    :return: Site inbreeding coefficient expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callstats_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of `call` or `callstats_expr` must be passed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inbreeding_coeff</span><span class="p">(</span>
        <span class="n">gt_counts</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">callstats_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check that AC, AN, and homozygote count are all ints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;callstats_expr must be a StructExpression containing fields &#39;AC&#39;,&quot;</span>
                <span class="s2">&quot; &#39;AN&#39;, and &#39;homozygote_count&#39; of types int32 or int64.&quot;</span>
            <span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span> <span class="o">/</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">q</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">inbreeding_coeff</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">call</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()))</span></div>


<div class="viewcode-block" id="fs_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.fs_from_sb">[docs]</a><span class="k">def</span> <span class="nf">fs_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">min_cell_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">min_p_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-320</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `FS` (Fisher strand balance) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    `FS` is the phred-scaled value of the double-sided Fisher exact test on strand balance.</span>

<span class="sd">    Using default values will have the same behavior as the GATK implementation, that is:</span>
<span class="sd">    - If sum(counts) &gt; 2*`min_cell_count` (default to GATK value of 200), they are normalized</span>
<span class="sd">    - If sum(counts) &lt; `min_count` (default to GATK value of 4), returns missing</span>
<span class="sd">    - Any p-value &lt; `min_p_value` (default to GATK value of 1e-320) is truncated to that value</span>

<span class="sd">    In addition to the default GATK behavior, setting `normalize` to `False` will perform a chi-squared test</span>
<span class="sd">    for large counts (&gt; `min_cell_count`) instead of normalizing the cell values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/FisherStrand.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :param normalize: Whether to normalize counts is sum(counts) &gt; min_cell_count (normalize=True), or use a chi sq instead of FET (normalize=False)</span>
<span class="sd">    :param min_cell_count: Maximum count for performing a FET</span>
<span class="sd">    :param min_count: Minimum total count to output FS (otherwise null it output)</span>
<span class="sd">    :return: FS value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb_sum</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="c1"># Normalize table if counts get too large</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sb_sum</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">sb_sum</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_cell_count</span><span class="p">,</span>
                <span class="n">sb</span><span class="p">,</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb_sum</span> <span class="o">/</span> <span class="n">min_cell_count</span><span class="p">))),</span>
            <span class="p">),</span>
            <span class="n">sb</span><span class="p">,</span>
            <span class="n">sb_sum</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># FET</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">fisher_exact_test</span><span class="p">(</span>
                    <span class="n">fs_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">contingency_table_test</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">min_cell_count</span><span class="o">=</span><span class="n">min_cell_count</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Return null if counts &lt;= `min_count`</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">sb_sum</span> <span class="o">&gt;</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs_expr</span><span class="p">)</span>  <span class="c1"># Needed to avoid -0.0 values</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sor_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.sor_from_sb">[docs]</a><span class="k">def</span> <span class="nf">sor_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `SOR` (Symmetric Odds Ratio test) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/StrandOddsRatio.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :return: SOR value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ref_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ref_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">alt_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alt_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">symmetrical_ratio</span> <span class="o">=</span> <span class="p">((</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ref_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span>
    <span class="n">alt_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="n">sor</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">symmetrical_ratio</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ref_ratio</span><span class="p">)</span> <span class="o">-</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alt_ratio</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sor</span></div>


<div class="viewcode-block" id="pab_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.pab_max_expr">[docs]</a><span class="k">def</span> <span class="nf">pab_max_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">la_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_alleles_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the maximum p-value of the binomial test for the alternate allele balance (PAB) for each allele.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can take a `gt_expr` and `ad_expr` that use local or global</span>
<span class="sd">        alleles. If they use local alleles, `la_expr` and `n_alleles_expr` should be</span>
<span class="sd">        provided to transform `gt_expr` and `ad_expr` to global alleles.</span>

<span class="sd">    :param gt_expr: Genotype call expression.</span>
<span class="sd">    :param ad_expr: Allele depth expression.</span>
<span class="sd">    :param la_expr: Allele local index expression. When provided `gt_expr` and</span>
<span class="sd">        `ad_expr` are transformed from using local alleles to global alleles using</span>
<span class="sd">        `la_expr`.</span>
<span class="sd">    :param n_alleles_expr: Number of alleles expression. Required when &#39;la_expr&#39; is</span>
<span class="sd">        provided.</span>
<span class="sd">    :return: Array expression of maximum p-values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">la_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_alleles_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide `n_alleles_expr` if `la_expr` is provided!&quot;</span><span class="p">)</span>

        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">local_to_global</span><span class="p">(</span>
            <span class="n">ad_expr</span><span class="p">,</span> <span class="n">la_expr</span><span class="p">,</span> <span class="n">n_alleles_expr</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="s2">&quot;R&quot;</span>
        <span class="p">)</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">lgt_to_gt</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">la_expr</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">binom_test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;two-sided&quot;</span><span class="p">)),</span>
        <span class="p">),</span>
        <span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>  <span class="c1"># Skip ref allele</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="bi_allelic_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_expr</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean expression selecting bi-allelic sites only, accounting for whether the input MT/HT was split.</span>

<span class="sd">    :param t: Input HT/MT</span>
<span class="sd">    :return: Boolean expression selecting only bi-allelic sites</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">was_split</span> <span class="k">if</span> <span class="s2">&quot;was_split&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">else</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="unphase_call_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.unphase_call_expr">[docs]</a><span class="k">def</span> <span class="nf">unphase_call_expr</span><span class="p">(</span><span class="n">call_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate unphased version of a call expression (which can be phased or not).</span>

<span class="sd">    :param call_expr: Input call expression</span>
<span class="sd">    :return: unphased call expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_diploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">call_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="region_flag_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.region_flag_expr">[docs]</a><span class="k">def</span> <span class="nf">region_flag_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">non_par</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prob_regions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a `region_flag` struct that contains flags for problematic regions (i.e., LCR, decoy, segdup, and nonpar regions).</span>

<span class="sd">    .. note:: No hg38 resources for decoy or self chain are available yet.</span>

<span class="sd">    :param t: Input Table/MatrixTable</span>
<span class="sd">    :param non_par: If True, flag loci that occur within pseudoautosomal regions on sex chromosomes</span>
<span class="sd">    :param prob_regions: If supplied, flag loci that occur within regions defined in Hail Table(s)</span>
<span class="sd">    :return: `region_flag` struct row annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prob_flags_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;non_par&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()}</span> <span class="k">if</span> <span class="n">non_par</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">prob_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prob_flags_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">region_name</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">region_table</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">region_name</span><span class="p">,</span> <span class="n">region_table</span> <span class="ow">in</span> <span class="n">prob_regions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">prob_flags_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="missing_callstats_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.missing_callstats_expr">[docs]</a><span class="k">def</span> <span class="nf">missing_callstats_expr</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a missing callstats struct for insertion into frequency annotation arrays when data is missing.</span>

<span class="sd">    :return: Hail Struct with missing values for each callstats element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">AC</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">AF</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">AN</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">homozygote_count</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="set_female_y_metrics_to_na_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.set_female_y_metrics_to_na_expr">[docs]</a><span class="k">def</span> <span class="nf">set_female_y_metrics_to_na_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">freq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span>
    <span class="n">freq_meta_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq_meta&quot;</span><span class="p">,</span>
    <span class="n">freq_index_dict_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq_index_dict&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set Y-variant frequency callstats for female-specific metrics to missing structs.</span>

<span class="sd">    :param t: Table or MatrixTable for which to adjust female metrics.</span>
<span class="sd">    :param freq_expr: Array expression or string annotation name for the frequency</span>
<span class="sd">        array. Default is &quot;freq&quot;.</span>
<span class="sd">    :param freq_meta_expr: Array expression or string annotation name for the frequency</span>
<span class="sd">        metadata. Default is &quot;freq_meta&quot;.</span>
<span class="sd">    :param freq_index_dict_expr: Dict expression or string annotation name for the</span>
<span class="sd">        frequency metadata index dictionary. Default is &quot;freq_index_dict&quot;.</span>
<span class="sd">    :return: Hail array expression to set female Y-variant metrics to missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_expr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_meta_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_meta_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_meta_expr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_index_dict_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_index_dict_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_index_dict_expr</span><span class="p">]</span>

    <span class="n">female_idx</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">freq_index_dict_expr</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">),</span> <span class="n">freq_index_dict_expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
    <span class="p">)</span>
    <span class="n">freq_idx_range</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta_expr</span><span class="p">))</span>

    <span class="n">new_freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
        <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_par</span><span class="p">()),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">female_idx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">missing_callstats_expr</span><span class="p">(),</span> <span class="n">freq_expr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">freq_idx_range</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">freq_expr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">new_freq_expr</span></div>


<div class="viewcode-block" id="hemi_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.hemi_expr">[docs]</a><span class="k">def</span> <span class="nf">hemi_expr</span><span class="p">(</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">male_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether genotypes are hemizygous.</span>

<span class="sd">    Return missing expression if locus is not in chrX/chrY non-PAR regions.</span>

<span class="sd">    :param locus: Input locus.</span>
<span class="sd">    :param sex_expr: Input StringExpression indicating whether sample is XX or XY.</span>
<span class="sd">    :param gt: Input genotype.</span>
<span class="sd">    :param xy_str: String indicating whether sample is XY. Default is &quot;XY&quot;.</span>
<span class="sd">    :return: BooleanExpression indicating whether genotypes are hemizygous.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span>
        <span class="c1"># Haploid genotypes have a single integer, so checking if</span>
        <span class="c1"># mt.GT[0] is alternate allele</span>
        <span class="n">gt</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sex_expr</span> <span class="o">==</span> <span class="n">male_str</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="merge_freq_arrays"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.merge_freq_arrays">[docs]</a><span class="k">def</span> <span class="nf">merge_freq_arrays</span><span class="p">(</span>
    <span class="n">farrays</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">fmeta</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">set_negatives_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">count_arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]],</span>
    <span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a list of frequency arrays based on the supplied `operation`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Arrays must be on the same Table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Arrays do not have to contain the same groupings or order of groupings but</span>
<span class="sd">        the array indices for a freq array in `farrays` must be the same as its associated</span>
<span class="sd">        frequency metadata index in `fmeta` i.e., `farrays = [freq1, freq2]` then `fmeta`</span>
<span class="sd">        must equal `[fmeta1, fmeta2]` where fmeta1 contains the metadata information</span>
<span class="sd">        for freq1.</span>

<span class="sd">        If `operation` is set to &quot;sum&quot;, groups in the merged array</span>
<span class="sd">        will be the union of groupings found within the arrays&#39; metadata and all arrays</span>
<span class="sd">        with be summed by grouping. If `operation` is set to &quot;diff&quot;, the merged array</span>
<span class="sd">        will contain groups only found in the first array of `fmeta`. Any array containing</span>
<span class="sd">        any of these groups will have thier values subtracted from the values of the first array.</span>

<span class="sd">    :param farrays: List of frequency arrays to merge. First entry in the list is the primary array to which other arrays will be added or subtracted. All arrays must be on the same Table.</span>
<span class="sd">    :param fmeta: List of frequency metadata for arrays being merged.</span>
<span class="sd">    :param operation: Merge operation to perform. Options are &quot;sum&quot; and &quot;diff&quot;. If &quot;diff&quot; is passed, the first freq array in the list will have the other arrays subtracted from it.</span>
<span class="sd">    :param set_negatives_to_zero: If True, set negative array values to 0 for AC, AN, AF, and homozygote_count. If False, raise a ValueError. Default is False.</span>
<span class="sd">    :param count_arrays: Dictionary of Lists of arrays containing counts to merge using the passed operation. Must use the same group indexing as fmeta. Keys are the descriptor names, values are Lists of arrays to merge. Default is None.</span>
<span class="sd">    :return: Tuple of merged frequency array, frequency metadata list and if `count_arrays` is not None, a dictionary of merged count arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">farrays</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide at least two frequency arrays to merge!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">farrays</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fmeta</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of farrays and fmeta must be equal!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;diff&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Operation must be either &#39;sum&#39; or &#39;diff&#39;!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count_arrays</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">count_array</span> <span class="ow">in</span> <span class="n">count_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">count_array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fmeta</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length of  count_array &#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39; and fmeta must be equal!&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Create a list where each entry is a dictionary whose key is an aggregation</span>
    <span class="c1"># group and the value is the corresponding index in the freq array.</span>
    <span class="n">fmeta</span> <span class="o">=</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fmeta</span><span class="p">]</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">|</span> <span class="n">j</span><span class="o">.</span><span class="n">key_set</span><span class="p">()),</span> <span class="n">fmeta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">key_set</span><span class="p">(),</span> <span class="n">fmeta</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Merge dictionaries in the list into a single dictionary where key is aggregation</span>
    <span class="c1"># group and the value is a list of the group&#39;s index in each of the freq arrays, if</span>
    <span class="c1"># it exists. For &quot;sum&quot; operation, use keys, aka groups, found in all freq dictionaries.</span>
    <span class="c1"># For &quot;diff&quot; operations, only use key_set from the first entry.</span>
    <span class="n">fmeta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">all_keys</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">key_set</span><span class="p">()))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)])</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">fmeta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">fmeta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
    <span class="p">)</span>

    <span class="c1"># Create a list of tuples from the dictionary, sorted by the list of indices for</span>
    <span class="c1"># each aggregation group.</span>
    <span class="n">fmeta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">fmeta</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Create a list of the aggregation groups, maintaining the sorted order.</span>
    <span class="n">new_freq_meta</span> <span class="o">=</span> <span class="n">fmeta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create array for each aggregation group of arrays containing the group&#39;s freq</span>
    <span class="c1"># values from each freq array.</span>
    <span class="n">freq_meta_idx</span> <span class="o">=</span> <span class="n">fmeta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">farrays</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

    <span class="k">def</span> <span class="nf">_sum_or_diff_fields</span><span class="p">(</span>
        <span class="n">field_1_expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field_2_expr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum or subtract fields in call statistics struct.</span>

<span class="sd">        :param field_1_expr: First field to sum or diff.</span>
<span class="sd">        :param field_2_expr: Second field to sum or diff.</span>
<span class="sd">        :return: Merged field value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">field_1_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">field_2_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">field_1_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">field_2_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1"># Iterate through the groups and their freq lists to merge callstats.</span>
    <span class="n">callstat_ann</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;AN&quot;</span><span class="p">,</span> <span class="s2">&quot;homozygote_count&quot;</span><span class="p">]</span>
    <span class="n">callstat_ann_af</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;AF&quot;</span><span class="p">,</span> <span class="s2">&quot;AN&quot;</span><span class="p">,</span> <span class="s2">&quot;homozygote_count&quot;</span><span class="p">]</span>
    <span class="n">new_freq</span> <span class="o">=</span> <span class="n">freq_meta_idx</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">AF</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">AN</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">AC</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">AN</span><span class="p">))</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="o">*</span><span class="n">callstat_ann_af</span>
            <span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span><span class="n">ann</span><span class="p">:</span> <span class="n">_sum_or_diff_fields</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">ann</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="n">ann</span><span class="p">])</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">callstat_ann</span><span class="p">}</span>
                <span class="p">),</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">callstat_ann</span><span class="p">),</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Create count_array_meta_idx using the fmeta then iterate through each group</span>
    <span class="c1"># in the list of tuples to access each group&#39;s entry per array. Sum or diff the</span>
    <span class="c1"># values for each group across arrays to make a new_counts_array annotation.</span>
    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="n">new_counts_array_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">count_array</span> <span class="ow">in</span> <span class="n">count_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">count_array_meta_idx</span> <span class="o">=</span> <span class="n">fmeta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">count_array</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">)</span>

            <span class="n">new_counts_array_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">count_array_meta_idx</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_sum_or_diff_fields</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span>
                    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="p">),</span>
            <span class="p">)</span>
    <span class="c1"># Check and see if any annotation within the merged array is negative. If so,</span>
    <span class="c1"># raise an error if set_negatives_to_zero is False or set the value to 0 if</span>
    <span class="c1"># set_negatives_to_zero is True.</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;diff&quot;</span><span class="p">:</span>
        <span class="n">negative_value_error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Negative values found in merged </span><span class="si">%s</span><span class="s2"> array. Review data or set&quot;</span>
            <span class="s2">&quot; `set_negatives_to_zero` to True to set negative values to 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">callstat_ann</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;AF&quot;</span><span class="p">)</span>
        <span class="n">new_freq</span> <span class="o">=</span> <span class="n">new_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">ann</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ann</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
                        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">ann</span><span class="p">])</span>
                        <span class="o">.</span><span class="n">or_error</span><span class="p">(</span><span class="n">negative_value_error_msg</span> <span class="o">%</span> <span class="s2">&quot;freq&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">callstat_ann</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">new_counts_array</span> <span class="ow">in</span> <span class="n">new_counts_array_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_counts_array_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_counts_array</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">or_error</span><span class="p">(</span><span class="n">negative_value_error_msg</span> <span class="o">%</span> <span class="s2">&quot;counts&quot;</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="n">new_freq_meta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">new_freq_meta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_freq</span><span class="p">,</span> <span class="n">new_freq_meta</span><span class="p">,</span> <span class="n">new_counts_array_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_freq</span><span class="p">,</span> <span class="n">new_freq_meta</span></div>


<div class="viewcode-block" id="merge_histograms"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.merge_histograms">[docs]</a><span class="k">def</span> <span class="nf">merge_histograms</span><span class="p">(</span><span class="n">hists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a list of histogram annotations.</span>

<span class="sd">    This function merges a list of histogram annotations by summing the arrays</span>
<span class="sd">    in an element-wise fashion. It keeps one &#39;bin_edge&#39; annotation but merges the</span>
<span class="sd">    &#39;bin_freq&#39;, &#39;n_smaller&#39;, and &#39;n_larger&#39; annotations by summing them.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Bin edges are assumed to be the same for all histograms.</span>

<span class="sd">    :param hists: List of histogram structs to merge.</span>
<span class="sd">    :return: Merged histogram struct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s2">&quot;bin_edges&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">),</span>
                <span class="s2">&quot;bin_freq&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint</span><span class="p">)])),</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint</span><span class="p">)])),</span>
                    <span class="n">fill_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)),</span>
                <span class="s2">&quot;n_smaller&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">n_smaller</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">n_smaller</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="s2">&quot;n_larger&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">n_larger</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">n_larger</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">),</span>
        <span class="n">hists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;bin_edges&quot;</span><span class="p">,</span> <span class="s2">&quot;bin_freq&quot;</span><span class="p">,</span> <span class="s2">&quot;n_smaller&quot;</span><span class="p">,</span> <span class="s2">&quot;n_larger&quot;</span><span class="p">),</span>
        <span class="n">hists</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
    <span class="p">)</span></div>


<span class="c1"># Functions used for computing allele frequency.</span>
<div class="viewcode-block" id="annotate_freq"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_freq">[docs]</a><span class="k">def</span> <span class="nf">annotate_freq</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subpop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsampling_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ds_pop_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">annotate_mt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate `mt` with stratified allele frequencies.</span>

<span class="sd">    The output Matrix table will include:</span>
<span class="sd">        - row annotation `freq` containing the stratified allele frequencies</span>
<span class="sd">        - global annotation `freq_meta` with metadata</span>
<span class="sd">        - global annotation `freq_meta_sample_count` with sample count information</span>

<span class="sd">    .. note::</span>

<span class="sd">        Currently this only supports bi-allelic sites.</span>

<span class="sd">        The input `mt` needs to have the following entry fields:</span>
<span class="sd">          - GT: a CallExpression containing the genotype</span>
<span class="sd">          - adj: a BooleanExpression containing whether the genotype is of high quality</span>
<span class="sd">            or not.</span>

<span class="sd">        All expressions arguments need to be expression on the input `mt`.</span>

<span class="sd">    .. rubric:: `freq` row annotation</span>

<span class="sd">    The `freq` row annotation is an Array of Structs, with each Struct containing the</span>
<span class="sd">    following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>

<span class="sd">    Each element of the array corresponds to a stratification of the data, and the</span>
<span class="sd">    metadata about these annotations is stored in the globals.</span>

<span class="sd">    .. rubric:: Global `freq_meta` metadata annotation</span>

<span class="sd">    The global annotation `freq_meta` is added to the input `mt`. It is a list of dict.</span>
<span class="sd">    Each element of the list contains metadata on a frequency stratification and the</span>
<span class="sd">    index in the list corresponds to the index of that frequency stratification in the</span>
<span class="sd">    `freq` row annotation.</span>

<span class="sd">    .. rubric:: Global `freq_meta_sample_count` annotation</span>

<span class="sd">    The global annotation `freq_meta_sample_count` is added to the input `mt`. This is a</span>
<span class="sd">    sample count per sample grouping defined in the `freq_meta` global annotation.</span>

<span class="sd">    .. rubric:: The `additional_strata_expr` parameter</span>

<span class="sd">    If the `additional_strata_expr` parameter is used, frequencies will be computed for</span>
<span class="sd">    each of the strata dictionaries across all values. For example, if</span>
<span class="sd">    `additional_strata_expr` is set to `[{&#39;platform&#39;: mt.platform},</span>
<span class="sd">    {&#39;platform&#39;:mt.platform, &#39;pop&#39;: mt.pop}, {&#39;age_bin&#39;: mt.age_bin}]`, then</span>
<span class="sd">    frequencies will be computed for each of the values of `mt.platform`, each of the</span>
<span class="sd">    combined values of `mt.platform` and `mt.pop`, and each of the values of</span>
<span class="sd">    `mt.age_bin`.</span>

<span class="sd">    .. rubric:: The `downsamplings` parameter</span>

<span class="sd">    If the `downsamplings` parameter is used without the `downsampling_expr`,</span>
<span class="sd">    frequencies will be computed for all samples and by population (if `pop_expr` is</span>
<span class="sd">    specified) by downsampling the number of samples without replacement to each of the</span>
<span class="sd">    numbers specified in the `downsamplings` array, provided that there are enough</span>
<span class="sd">    samples in the dataset. In addition, if `pop_expr` is specified, a downsampling to</span>
<span class="sd">    each of the exact number of samples present in each population is added. Note that</span>
<span class="sd">    samples are randomly sampled only once, meaning that the lower downsamplings are</span>
<span class="sd">    subsets of the higher ones. If the `downsampling_expr` parameter is used with the</span>
<span class="sd">    `downsamplings` parameter, the `downsamplings` parameter informs the function which</span>
<span class="sd">    downsampling groups were already created and are to be used in the frequency</span>
<span class="sd">    calculation.</span>

<span class="sd">    .. rubric:: The `downsampling_expr` and `ds_pop_counts` parameters</span>

<span class="sd">    If the `downsampling_expr` parameter is used, `downsamplings` must also be set</span>
<span class="sd">    and frequencies will be computed for all samples and by population (if `pop_expr`</span>
<span class="sd">    is specified) using the downsampling indices to each of the numbers specified in</span>
<span class="sd">    the `downsamplings` array. The function expects a &#39;global_idx&#39;, and if `pop_expr`</span>
<span class="sd">    is used, a &#39;pop_idx&#39; within the `downsampling_expr` to be used to determine if a</span>
<span class="sd">    sample belongs within a certain downsampling group, i.e. the index is less than</span>
<span class="sd">    the group size. `The function `annotate_downsamplings` can be used to to create</span>
<span class="sd">    the `downsampling_expr`, `downsamplings`, and `ds_pop_counts` expressions.</span>

<span class="sd">    .. rubric:: The `entry_agg_funcs` parameter</span>

<span class="sd">    If the `entry_agg_funcs` parameter is used, the output MatrixTable will also</span>
<span class="sd">    contain the annotations specified in the `entry_agg_funcs` parameter. The keys of</span>
<span class="sd">    the dict are the names of the annotations and the values are tuples of functions.</span>
<span class="sd">    The first function is used to transform the `mt` entries in some way, and the</span>
<span class="sd">    second function is used to aggregate the output from the first function. For</span>
<span class="sd">    example, if `entry_agg_funcs` is set to {&#39;adj_samples&#39;: (get_adj_expr, hl.agg.sum)}`,</span>
<span class="sd">    then the output MatrixTable will contain an annotation `adj_samples` which is an</span>
<span class="sd">    array of the number of adj samples per strata in each row.</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :param sex_expr: When specified, frequencies are stratified by sex. If `pop_expr`</span>
<span class="sd">        is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param pop_expr: When specified, frequencies are stratified by population. If</span>
<span class="sd">        `sex_expr` is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param subpop_expr: When specified, frequencies are stratified by sub-continental</span>
<span class="sd">        population. Note that `pop_expr` is required as well when using this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, frequencies are stratified by the</span>
<span class="sd">        given additional strata. This can e.g. be used to stratify by platform,</span>
<span class="sd">        platform-pop, platform-pop-sex.</span>
<span class="sd">    :param downsamplings: When specified, frequencies are computed by downsampling the</span>
<span class="sd">        data to the number of samples given in the list. Note that if `pop_expr` is</span>
<span class="sd">        specified, downsamplings by population is also computed.</span>
<span class="sd">    :param downsampling_expr: When specified, frequencies are computed using the</span>
<span class="sd">        downsampling indices in the provided StructExpression. Note that if `pop_idx`</span>
<span class="sd">        is specified within the struct, downsamplings by population is also computed.</span>
<span class="sd">    :param ds_pop_counts: When specified, frequencies are computed by downsampling the</span>
<span class="sd">        data to the number of samples per pop in the dict. The key is the population</span>
<span class="sd">        and the value is the number of samples.</span>
<span class="sd">    :param entry_agg_funcs: When specified, additional annotations are added to the</span>
<span class="sd">        output Table/MatrixTable. The keys of the dict are the names of the annotations</span>
<span class="sd">        and the values are tuples of functions. The first function is used to transform</span>
<span class="sd">        the `mt` entries in some way, and the second function is used to aggregate the</span>
<span class="sd">        output from the first function.</span>
<span class="sd">    :param annotate_mt: Whether to return the full MatrixTable with annotations added</span>
<span class="sd">        instead of only a Table with `freq` and other annotations. Default is True.</span>
<span class="sd">    :return: MatrixTable or Table with `freq` annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;annotate_freq requires `downsamplings` when using `downsampling_expr`&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ds_pop_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `ds_pop_counts` when using &quot;</span>
                    <span class="s2">&quot;`downsampling_expr` with pop_idx&quot;</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Generate downsamplings and assign downsampling_expr if it is None when</span>
    <span class="c1"># downsamplings is supplied.</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ds_ht</span> <span class="o">=</span> <span class="n">annotate_downsamplings</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">downsamplings</span><span class="p">,</span> <span class="n">pop_expr</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ds_ht</span><span class="o">.</span><span class="n">downsamplings</span><span class="p">)</span>
        <span class="n">ds_pop_counts</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ds_ht</span><span class="o">.</span><span class="n">ds_pop_counts</span><span class="p">)</span>
        <span class="n">downsampling_expr</span> <span class="o">=</span> <span class="n">ds_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span><span class="o">.</span><span class="n">downsampling</span>

    <span class="c1"># Build list of all stratification groups to be used in the frequency calculation.</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="n">build_freq_stratification_list</span><span class="p">(</span>
        <span class="n">sex_expr</span><span class="o">=</span><span class="n">sex_expr</span><span class="p">,</span>
        <span class="n">pop_expr</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">,</span>
        <span class="n">subpop_expr</span><span class="o">=</span><span class="n">subpop_expr</span><span class="p">,</span>
        <span class="n">additional_strata_expr</span><span class="o">=</span><span class="n">additional_strata_expr</span><span class="p">,</span>
        <span class="n">downsampling_expr</span><span class="o">=</span><span class="n">downsampling_expr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Annotate the MT cols with each of the expressions in strata_expr and redefine</span>
    <span class="c1"># strata_expr based on the column HT with added annotations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">}</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">]</span>

    <span class="c1"># Annotate HT with a freq_meta global and group membership array for each sample</span>
    <span class="c1"># indicating whether the sample belongs to the group defined by freq_meta elements.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">generate_freq_group_membership_array</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="n">strata_expr</span><span class="p">,</span>
        <span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">,</span>
        <span class="n">ds_pop_counts</span><span class="o">=</span><span class="n">ds_pop_counts</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">freq_ht</span> <span class="o">=</span> <span class="n">compute_freq_by_strata</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span><span class="o">.</span><span class="n">group_membership</span><span class="p">),</span>
        <span class="n">entry_agg_funcs</span><span class="o">=</span><span class="n">entry_agg_funcs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">freq_ht</span> <span class="o">=</span> <span class="n">freq_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">annotate_mt</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="n">freq_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">])</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">freq_ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">mt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">freq_ht</span></div>


<div class="viewcode-block" id="annotate_downsamplings"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_downsamplings">[docs]</a><span class="k">def</span> <span class="nf">annotate_downsamplings</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">pop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate MatrixTable or Table with downsampling groups.</span>

<span class="sd">    :param t: Input MatrixTable or Table.</span>
<span class="sd">    :param downsamplings: List of downsampling sizes.</span>
<span class="sd">    :param pop_expr: Optional expression for population group. When provided, population</span>
<span class="sd">        sample sizes are added as values to downsamplings.</span>
<span class="sd">    :return: MatrixTable or Table with downsampling annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">rand_unif</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Add a global index for use in computing frequencies, or other aggregate stats on</span>
    <span class="c1"># the downsamplings.</span>
    <span class="n">scan_expr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;global_idx&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">count</span><span class="p">()}</span>

    <span class="c1"># If pop_expr is provided, add all pop counts to the downsamplings list.</span>
    <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pop_counts</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">pop</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">pop</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">downsamplings</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pop_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">downsamplings</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">pop_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="c1"># Add an index by pop for use in computing frequencies, or other aggregate stats</span>
        <span class="c1"># on the downsamplings.</span>
        <span class="n">scan_expr</span><span class="p">[</span><span class="s2">&quot;pop_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pop_counts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> downsamplings: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">downsamplings</span><span class="p">),</span> <span class="n">downsamplings</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">scan_expr</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">scan_expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">,</span>
        <span class="n">ds_pop_counts</span><span class="o">=</span><span class="n">pop_counts</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span></div>


<div class="viewcode-block" id="build_freq_stratification_list"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.build_freq_stratification_list">[docs]</a><span class="k">def</span> <span class="nf">build_freq_stratification_list</span><span class="p">(</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subpop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsampling_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a list of stratification groupings to be used in frequency calculations based on supplied parameters.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. The returned list of stratifications can be passed to</span>
<span class="sd">        `generate_freq_group_membership_array`.</span>

<span class="sd">    :param sex_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        sex. If `pop_expr` is also specified, then the returned list also contains a</span>
<span class="sd">        pop/sex stratification.</span>
<span class="sd">    :param pop_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        population. If `sex_expr` is also specified, then the returned list also</span>
<span class="sd">        contains a pop/sex stratification.</span>
<span class="sd">    :param subpop_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        sub-continental population. Note that `pop_expr` is required as well when using</span>
<span class="sd">        this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, the returned list contains a</span>
<span class="sd">        stratification for each of the additional strata. This can e.g. be used to</span>
<span class="sd">        stratify by platform, platform-pop, platform-pop-sex.</span>
<span class="sd">    :param downsampling_expr: When specified, the returned list contains a</span>
<span class="sd">        stratification for downsampling. If `pop_expr` is also specified, then the</span>
<span class="sd">        returned list also contains a downsampling/pop stratification.</span>
<span class="sd">    :return: List of dictionaries specifying stratification groups where the keys of</span>
<span class="sd">        each dictionary are strings and the values are corresponding expressions that</span>
<span class="sd">        define the values to stratify frequency calculations by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;annotate_freq requires pop_expr when using subpop_expr&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;global_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;annotate_freq requires `downsampling_expr` with key &#39;global_idx&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `downsampling_expr` with key &#39;pop_idx&#39; when&quot;</span>
                    <span class="s2">&quot; using `pop_expr`&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `pop_expr` when using `downsampling_expr` &quot;</span>
                    <span class="s2">&quot;with pop_idx&quot;</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Build list of strata expressions based on supplied parameters.</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop_expr</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">sex_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex_expr</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop_expr</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex_expr</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop_expr</span><span class="p">,</span> <span class="s2">&quot;subpop&quot;</span><span class="p">:</span> <span class="n">subpop_expr</span><span class="p">})</span>

    <span class="c1"># Add downsampling to strata expressions, include pop in the strata if supplied.</span>
    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downsampling_strata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="n">downsampling_expr</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">downsampling_strata</span><span class="p">[</span><span class="s2">&quot;pop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop_expr</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsampling_strata</span><span class="p">)</span>

    <span class="c1"># Add additional strata expressions.</span>
    <span class="k">if</span> <span class="n">additional_strata_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additional_strata_expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">additional_strata_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">additional_strata_expr</span><span class="p">]</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">additional_strata_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">strata_expr</span></div>


<div class="viewcode-block" id="generate_freq_group_membership_array"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.generate_freq_group_membership_array">[docs]</a><span class="k">def</span> <span class="nf">generate_freq_group_membership_array</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">strata_expr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ds_pop_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_zero_sample_groups</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">no_raw_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Table with a &#39;group_membership&#39; array for each sample indicating whether the sample belongs to specific stratification groups.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. Please see the `annotate_freq` function for more</span>
<span class="sd">        complete documentation.</span>

<span class="sd">    The following global annotations are added to the returned Table:</span>
<span class="sd">        - freq_meta: Each element of the list contains metadata on a stratification</span>
<span class="sd">          group.</span>
<span class="sd">        - freq_meta_sample_count: sample count per grouping defined in `freq_meta`.</span>
<span class="sd">        - If downsamplings or ds_pop_counts are specified, they are also added as</span>
<span class="sd">          global annotations on the returned Table.</span>

<span class="sd">    Each sample is annotated with a &#39;group_membership&#39; array indicating whether the</span>
<span class="sd">    sample belongs to specific stratification groups. All possible value combinations</span>
<span class="sd">    are determined for each stratification grouping in the `strata_expr` list.</span>

<span class="sd">    :param ht: Input Table that contains Expressions specified by `strata_expr`.</span>
<span class="sd">    :param strata_expr: List of dictionaries specifying stratification groups where</span>
<span class="sd">        the keys of each dictionary are strings and the values are corresponding</span>
<span class="sd">        expressions that define the values to stratify frequency calculations by.</span>
<span class="sd">    :param downsamplings: List of downsampling values to include in the stratifications.</span>
<span class="sd">    :param ds_pop_counts: Dictionary of population counts for each downsampling value.</span>
<span class="sd">    :param remove_zero_sample_groups: Whether to remove groups with a sample count of 0.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :param no_raw_group: Whether to remove the raw group from the &#39;group_membership&#39;</span>
<span class="sd">        annotation and the &#39;freq_meta&#39; and &#39;freq_meta_sample_count&#39; global annotations.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :return: Table with the &#39;group_membership&#39; array annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ds_in_strata</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">)</span>
    <span class="n">global_idx_in_ds_expr</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
        <span class="s2">&quot;global_idx&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;downsampling&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span> <span class="k">if</span> <span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span>
    <span class="p">)</span>
    <span class="n">pop_in_strata</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">)</span>
    <span class="n">pop_idx_in_ds_expr</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
        <span class="s2">&quot;pop_idx&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;downsampling&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span>
        <span class="k">if</span> <span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">ds_pop_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ds_in_strata</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression when downsamplings&quot;</span>
            <span class="s2">&quot;are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">global_idx_in_ds_expr</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression with &#39;global_idx&#39; when &quot;</span>
            <span class="s2">&quot;downsamplings are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">ds_pop_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pop_in_strata</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a population expression &#39;pop&#39; when ds_pop_counts &quot;</span>
            <span class="s2">&quot; are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">ds_pop_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pop_idx_in_ds_expr</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression with &#39;pop_idx&#39; when &quot;</span>
            <span class="s2">&quot;ds_pop_counts are provided.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Get counters for all strata.</span>
    <span class="n">strata_counts</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">}))</span>
                <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">strata_expr</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Add all desired strata to sample group filters.</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[({},</span> <span class="kc">True</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">:</span>
        <span class="n">downsampling_expr</span> <span class="o">=</span> <span class="n">strata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">)</span>
        <span class="n">strata_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Add to all downsampling groups, both global and population-specific, to</span>
        <span class="c1"># strata.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;downsampling&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downsamplings</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strata_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{})]</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;pop&quot;</span> <span class="ow">and</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="s2">&quot;global&quot;</span><span class="p">))</span>
            <span class="n">strata_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Get all combinations of strata values.</span>
        <span class="n">strata_combinations</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">strata_values</span><span class="p">)</span>
        <span class="c1"># Create sample group filters that are evaluated on each sample for each strata</span>
        <span class="c1"># combination. Strata combinations are evaluated as a logical AND, e.g.</span>
        <span class="c1"># {&quot;pop&quot;:nfe, &quot;downsampling&quot;:1000} or &quot;nfe-10000&quot; creates the filter expression</span>
        <span class="c1"># pop == nfe AND downsampling pop_idx &lt; 10000.</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">strata_combinations</span><span class="p">:</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">)</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">)</span>
            <span class="c1"># If combo contains downsampling, determine the downsampling index</span>
            <span class="c1"># annotation to use.</span>
            <span class="n">downsampling_idx</span> <span class="o">=</span> <span class="s2">&quot;global_idx&quot;</span>
            <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pop</span> <span class="o">!=</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t include population downsamplings where the downsampling is</span>
                    <span class="c1"># larger than the number of samples in the population.</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="o">&gt;</span> <span class="n">ds_pop_counts</span><span class="p">[</span><span class="n">pop</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">downsampling_idx</span> <span class="o">=</span> <span class="s2">&quot;pop_idx&quot;</span>

            <span class="c1"># If combo contains downsampling, add downsampling filter expression.</span>
            <span class="n">combo_filter_exprs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combo</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;downsampling&quot;</span><span class="p">:</span>
                    <span class="n">combo_filter_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsampling_expr</span><span class="p">[</span><span class="n">downsampling_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;pop&quot;</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">!=</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
                        <span class="n">combo_filter_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combo</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">combo</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">combo_filter_exprs</span><span class="p">)))</span>

    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_group_filters</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;number of filters: </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n_groups</span><span class="p">)</span>

    <span class="c1"># Get sample count per strata group.</span>
    <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_zero_sample_groups</span><span class="p">:</span>
        <span class="n">filter_freq</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">freq_meta_sample_count</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">filter_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">idx_keep</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">filter_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_group_filters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_keep</span><span class="p">]</span>

    <span class="c1"># Annotate columns with group_membership.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">])</span>

    <span class="c1"># Create and annotate global expression with meta and sample count information.</span>
    <span class="n">freq_meta</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">sample_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;adj&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_group</span> <span class="ow">in</span> <span class="n">sample_group_filters</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_raw_group</span><span class="p">:</span>
        <span class="c1"># Sample group membership for the &quot;raw&quot; group, representing all samples, is</span>
        <span class="c1"># the same as the first group in the group_membership array.</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">group_membership</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ht</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">ht</span><span class="o">.</span><span class="n">group_membership</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Add the &quot;raw&quot; group, representing all samples, to the freq_meta_expr list.</span>
        <span class="n">freq_meta</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;raw&quot;</span><span class="p">})</span>
        <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">freq_meta_sample_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">freq_meta_sample_count</span>
        <span class="p">)</span>

    <span class="n">global_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;freq_meta&quot;</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">,</span>
        <span class="s2">&quot;freq_meta_sample_count&quot;</span><span class="p">:</span> <span class="n">freq_meta_sample_count</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;downsamplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsamplings</span>
    <span class="k">if</span> <span class="n">ds_pop_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;ds_pop_counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_pop_counts</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span><span class="o">**</span><span class="n">global_expr</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;group_membership&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="compute_freq_by_strata"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.compute_freq_by_strata">[docs]</a><span class="k">def</span> <span class="nf">compute_freq_by_strata</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">select_fields</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_membership_includes_raw_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute call statistics and, when passed, entry aggregation function(s) by strata.</span>

<span class="sd">    The computed call statistics are AC, AF, AN, and homozygote_count. The entry</span>
<span class="sd">    aggregation functions are applied to the MatrixTable entries and aggregated. The</span>
<span class="sd">    MatrixTable must contain a &#39;group_membership&#39; annotation (like the one added by</span>
<span class="sd">    `generate_freq_group_membership_array`) that is a list of bools to aggregate the</span>
<span class="sd">    columns by.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. Please see the `annotate_freq` function for more</span>
<span class="sd">        complete documentation.</span>

<span class="sd">    :param mt: Input MatrixTable.</span>
<span class="sd">    :param entry_agg_funcs: Optional dict of entry aggregation functions. When</span>
<span class="sd">        specified, additional annotations are added to the output Table/MatrixTable.</span>
<span class="sd">        The keys of the dict are the names of the annotations and the values are tuples</span>
<span class="sd">        of functions. The first function is used to transform the `mt` entries in some</span>
<span class="sd">        way, and the second function is used to aggregate the output from the first</span>
<span class="sd">        function.</span>
<span class="sd">    :param select_fields: Optional list of row fields from `mt` to keep on the output</span>
<span class="sd">        Table.</span>
<span class="sd">    :param group_membership_includes_raw_group: Whether the &#39;group_membership&#39;</span>
<span class="sd">        annotation includes an entry for the &#39;raw&#39; group, representing all samples. If</span>
<span class="sd">        False, the &#39;raw&#39; group is inserted as the second element in all added</span>
<span class="sd">        annotations using the same &#39;group_membership&#39;, resulting</span>
<span class="sd">        in array lengths of &#39;group_membership&#39;+1. If True, the second element of each</span>
<span class="sd">        added annotation is still the &#39;raw&#39; group, but the group membership is</span>
<span class="sd">        determined by the values in the second element of &#39;group_membership&#39;, and the</span>
<span class="sd">        output annotations will be the same length as &#39;group_membership&#39;. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    :return: Table or MatrixTable with allele frequencies by strata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">entry_agg_funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">entry_agg_funcs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">select_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">select_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">count_cols</span><span class="p">()</span>
    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">localize_entries</span><span class="p">(</span><span class="s2">&quot;entries&quot;</span><span class="p">,</span> <span class="s2">&quot;cols&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="n">indices_by_group</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_groups</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">g_i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">s_i</span><span class="p">:</span> <span class="n">ht</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Pull out each annotation that will be used in the array aggregation below as its</span>
    <span class="c1"># own ArrayExpression. This is important to prevent memory issues when performing</span>
    <span class="c1"># the below array aggregations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="o">*</span><span class="n">select_fields</span><span class="p">,</span>
        <span class="n">adj_array</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">adj</span><span class="p">),</span>
        <span class="n">gt_array</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">GT</span><span class="p">),</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">ann</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">ht</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entry_agg_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">},</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_agg_by_group</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">agg_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ann_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregate `agg_expr` by group using the `agg_func` function.</span>

<span class="sd">        :param ht: Input Hail Table.</span>
<span class="sd">        :param agg_func: Aggregation function to apply to `agg_expr`.</span>
<span class="sd">        :param agg_expr: Expression to aggregate by group.</span>
<span class="sd">        :param args: Additional arguments to pass to the `agg_func`.</span>
<span class="sd">        :return: Aggregated array expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj_agg_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">indices_by_group</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s_indices</span><span class="p">:</span> <span class="n">s_indices</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">adj_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">ann_expr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Create final agg list by inserting or changing the &quot;raw&quot; group,</span>
        <span class="c1"># representing all samples, in the adj_agg_list.</span>
        <span class="n">raw_agg_expr</span> <span class="o">=</span> <span class="n">ann_expr</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">group_membership_includes_raw_group</span><span class="p">:</span>
            <span class="n">extend_idx</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extend_idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">adj_agg_expr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">adj_agg_expr</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw_agg_expr</span><span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adj_agg_expr</span><span class="p">[</span><span class="n">extend_idx</span><span class="p">:])</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">adj_agg_expr</span>

    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">_agg_by_group</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">gt_array</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>

    <span class="c1"># Select non-ref allele (assumes bi-allelic).</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">freq_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">cs</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AC</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">AF</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">homozygote_count</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Add annotations for any supplied entry transform and aggregation functions.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="o">*</span><span class="n">select_fields</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span><span class="n">ann</span><span class="p">:</span> <span class="n">_agg_by_group</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ht</span><span class="p">[</span><span class="n">ann</span><span class="p">])</span> <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entry_agg_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq_expr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;cols&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="update_structured_annotations"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.update_structured_annotations">[docs]</a><span class="k">def</span> <span class="nf">update_structured_annotations</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotation_update_exprs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">annotation_update_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update highly structured annotations on a Table.</span>

<span class="sd">    This function recursively updates annotations defined by `annotation_update_exprs`</span>
<span class="sd">    and if `annotation_update_label` is supplied, it checks if the sample annotations</span>
<span class="sd">    are different from the input and adds a flag to the Table, indicating which</span>
<span class="sd">    annotations have been updated for each sample.</span>

<span class="sd">    :param ht: Input Table with structured annotations to update.</span>
<span class="sd">    :param annotation_update_exprs: Dictionary of annotations to update, structured as</span>
<span class="sd">        they are structured on the input `ht`.</span>
<span class="sd">    :param annotation_update_label: Optional string of the label to use for an</span>
<span class="sd">        annotation indicating which annotations have been updated. Default is None, so</span>
<span class="sd">        no annotation is added.</span>
<span class="sd">    :return: Table with updated annotations and optionally a flag indicating which</span>
<span class="sd">        annotations were changed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_update_struct</span><span class="p">(</span>
        <span class="n">struct_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
        <span class="n">update_exprs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a StructExpression.</span>

<span class="sd">        :param struct_expr: StructExpression to update.</span>
<span class="sd">        :param update_exprs: Dictionary of annotations to update.</span>
<span class="sd">        :return: Tuple of the updated annotations and the updated flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">update_exprs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">updated_struct_expr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">updated_flag_expr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">update_exprs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">struct_expr</span><span class="p">:</span>
                    <span class="n">updated_flag</span><span class="p">,</span> <span class="n">updated_ann</span> <span class="o">=</span> <span class="n">_update_struct</span><span class="p">(</span><span class="n">struct_expr</span><span class="p">[</span><span class="n">ann</span><span class="p">],</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">updated_flag</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
                    <span class="n">updated_ann</span> <span class="o">=</span> <span class="n">expr</span>
                <span class="n">updated_flag_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">ann</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">updated_flag</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="p">)</span>
                <span class="n">updated_struct_expr</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_ann</span>
            <span class="k">return</span> <span class="n">updated_flag_expr</span><span class="p">,</span> <span class="n">struct_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">updated_struct_expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">update_exprs</span> <span class="o">!=</span> <span class="n">struct_expr</span><span class="p">},</span> <span class="n">update_exprs</span>

    <span class="n">annotation_update_flag</span><span class="p">,</span> <span class="n">updated_rows</span> <span class="o">=</span> <span class="n">_update_struct</span><span class="p">(</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">row_value</span><span class="p">,</span> <span class="n">annotation_update_exprs</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">annotation_update_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">updated_rows</span> <span class="o">=</span> <span class="n">updated_rows</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">annotation_update_label</span><span class="p">:</span> <span class="n">filter_utils</span><span class="o">.</span><span class="n">add_filters_expr</span><span class="p">(</span>
                    <span class="n">filters</span><span class="o">=</span><span class="n">annotation_update_flag</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">updated_rows</span><span class="p">)</span></div>


<div class="viewcode-block" id="gks_compute_seqloc_digest"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.gks_compute_seqloc_digest">[docs]</a><span class="k">def</span> <span class="nf">gks_compute_seqloc_digest</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">export_tmpfile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">computed_tmpfile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute sequence location digest-based id for a hail variant Table.</span>

<span class="sd">    Exports table to tsv, computes SequenceLocation digests, reimports and replaces</span>
<span class="sd">    the vrs_json field with the result. Input table must have a .vrs field, like the</span>
<span class="sd">    one added by add_gks_vrs, that can be used to construct ga4gh.vrs models.</span>

<span class="sd">    :param ht: hail table with VRS annotation</span>
<span class="sd">    :param export_tmpfile: Optional file path to export the table to.</span>
<span class="sd">    :param computed_tmpfile: Optional file path to write the updated rows to,</span>
<span class="sd">        which is then imported as a hail table</span>
<span class="sd">    :return: a hail table with the VRS annotation updated with the new SequenceLocations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: The pinned ga4gh.vrs module breaks logging when this annotations module is</span>
    <span class="c1"># imported. Importing ga4gh here to avoid this issue.</span>
    <span class="kn">import</span> <span class="nn">ga4gh.core</span> <span class="k">as</span> <span class="nn">ga4gh_core</span>
    <span class="kn">import</span> <span class="nn">ga4gh.vrs</span> <span class="k">as</span> <span class="nn">ga4gh_vrs</span>

    <span class="k">if</span> <span class="n">export_tmpfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">export_tmpfile</span> <span class="o">=</span> <span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;gks-seqloc-pre.tsv&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">computed_tmpfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">computed_tmpfile</span> <span class="o">=</span> <span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;gks-seqloc-post.tsv&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exporting ht to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">export_tmpfile</span><span class="p">)</span>
    <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;vrs_json&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">export_tmpfile</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Computing SequenceLocation digests and writing to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">computed_tmpfile</span>
    <span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">computed_tmpfile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_out</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">export_tmpfile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">f_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
                    <span class="n">f_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">locus</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">vrs_json</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">vrs_variant</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">vrs_json</span><span class="p">)</span>
                    <span class="n">location</span> <span class="o">=</span> <span class="n">vrs_variant</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
                    <span class="n">location</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
                    <span class="n">location_id</span> <span class="o">=</span> <span class="n">ga4gh_core</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">ga4gh_identify</span><span class="p">(</span>
                        <span class="n">ga4gh_vrs</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">SequenceLocation</span><span class="p">(</span><span class="o">**</span><span class="n">location</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">vrs_variant</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">][</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location_id</span>
                    <span class="c1"># serialize outputs to JSON and write to TSV</span>
                    <span class="n">vrs_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">vrs_variant</span><span class="p">)</span>
                    <span class="n">alleles</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span>
                    <span class="n">f_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">locus</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">vrs_json</span><span class="p">]))</span>
                    <span class="n">f_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Computed </span><span class="si">%s</span><span class="s2"> SequenceLocation digests in </span><span class="si">%s</span><span class="s2"> seconds&quot;</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Importing VRS records with computed SequenceLocation digests&quot;</span><span class="p">)</span>
    <span class="n">ht_with_location</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">import_table</span><span class="p">(</span>
        <span class="n">computed_tmpfile</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;locus&quot;</span><span class="p">:</span> <span class="s2">&quot;tstr&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">:</span> <span class="s2">&quot;tstr&quot;</span><span class="p">,</span> <span class="s2">&quot;vrs_json&quot;</span><span class="p">:</span> <span class="s2">&quot;tstr&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">ht_with_location_parsed</span> <span class="o">=</span> <span class="n">ht_with_location</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">locus</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">(</span>
            <span class="n">contig</span><span class="o">=</span><span class="n">ht_with_location</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ht_with_location</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">reference_genome</span><span class="o">=</span><span class="s2">&quot;GRCh38&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">alleles</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">parse_json</span><span class="p">(</span><span class="n">ht_with_location</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;vrs_json&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ht_with_location_parsed</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_gks_vrs"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_gks_vrs">[docs]</a><span class="k">def</span> <span class="nf">add_gks_vrs</span><span class="p">(</span>
    <span class="n">input_locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
    <span class="n">input_vrs</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dictionary containing VRS information from a given locus and struct of VRS information.</span>

<span class="sd">    Dict will have GA4GH GKS VRS structure.</span>

<span class="sd">    :param input_locus: Locus field from a struct (locus of result of running .collect() on a Hail table).</span>
<span class="sd">    :param input_vrs: VRS struct (such as from a ht.info.vrs field).</span>
<span class="sd">    :return: Python dictionary conforming to GA4GH GKS VRS structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: The pinned ga4gh.vrs module breaks logging when this annotations module is</span>
    <span class="c1"># imported. Importing ga4gh here to avoid this issue.</span>
    <span class="kn">import</span> <span class="nn">ga4gh.core</span> <span class="k">as</span> <span class="nn">ga4gh_core</span>
    <span class="kn">import</span> <span class="nn">ga4gh.vrs</span> <span class="k">as</span> <span class="nn">ga4gh_vrs</span>

    <span class="n">build_in</span> <span class="o">=</span> <span class="n">input_locus</span><span class="o">.</span><span class="n">reference_genome</span><span class="o">.</span><span class="n">name</span>
    <span class="n">chr_in</span> <span class="o">=</span> <span class="n">input_locus</span><span class="o">.</span><span class="n">contig</span>

    <span class="n">chrom_dict</span> <span class="o">=</span> <span class="n">VRS_CHROM_IDS</span><span class="p">[</span><span class="n">build_in</span><span class="p">]</span>
    <span class="n">vrs_id</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Allele_IDs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_chrom_id</span> <span class="o">=</span> <span class="n">chrom_dict</span><span class="p">[</span><span class="n">chr_in</span><span class="p">]</span>
    <span class="n">vrs_start_value</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Starts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_end_value</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Ends</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_state_sequence</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_States</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">vrs_dict_out</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">vrs_id</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Allele&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;SequenceLocation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sequence_id&quot;</span><span class="p">:</span> <span class="n">vrs_chrom_id</span><span class="p">,</span>
            <span class="s2">&quot;interval&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">vrs_start_value</span><span class="p">},</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">vrs_end_value</span><span class="p">},</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;SequenceInterval&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">},</span>
        <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;LiteralSequenceExpression&quot;</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">:</span> <span class="n">vrs_state_sequence</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="n">location_id</span> <span class="o">=</span> <span class="n">ga4gh_core</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">ga4gh_identify</span><span class="p">(</span>
        <span class="n">ga4gh_vrs</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">SequenceLocation</span><span class="p">(</span><span class="o">**</span><span class="n">vrs_dict_out</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="n">vrs_dict_out</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">][</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location_id</span>

    <span class="k">return</span> <span class="n">vrs_dict_out</span></div>


<div class="viewcode-block" id="add_gks_va"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_gks_va">[docs]</a><span class="k">def</span> <span class="nf">add_gks_va</span><span class="p">(</span>
    <span class="n">input_struct</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span>
    <span class="n">label_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gnomAD&quot;</span><span class="p">,</span>
    <span class="n">label_version</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;3.1.2&quot;</span><span class="p">,</span>
    <span class="n">ancestry_groups</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ancestry_groups_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">by_sex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">freq_index_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Python dictionary containing GKS VA annotations.</span>

<span class="sd">    Populate the dictionary with frequency information conforming to the GKS VA frequency schema.</span>
<span class="sd">    If ancestry_groups or by_sex is provided, also include subcohort schemas for each cohort.</span>
<span class="sd">    If input_struct has mean_depth, it is added to ancillaryResults.</span>
<span class="sd">    This annotation is added under the gks_va_freq_dict field of the table.</span>
<span class="sd">    The focusAllele field is not populated, and must be filled in by the caller.</span>

<span class="sd">    :param input_struct: Hail struct for a desired variant (such as result of running .collect()[0] on a Table).</span>
<span class="sd">    :param label_name: Label name to use within the returned dictionary. Example: &quot;gnomAD&quot;.</span>
<span class="sd">    :param label_version: String listing the version of the table being used. Example: &quot;3.1.2&quot;.</span>
<span class="sd">    :param ancestry_groups: List of strings of shortened names of cohorts to return results for.</span>
<span class="sd">        Example: [&#39;afr&#39;,&#39;fin&#39;,&#39;nfe&#39;]. Default is None.</span>
<span class="sd">    :param ancestry_groups_dict: Dict mapping shortened genetic ancestry group names to full names.</span>
<span class="sd">        Example: {&#39;afr&#39;:&#39;African/African American&#39;}. Default is None.</span>
<span class="sd">    :param by_sex: Boolean to include breakdown of cohorts by inferred sex (XX and XY) as well.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    :freq_index_dict: Dict mapping groups to their index for freq info in ht.freq_index_dict[0].</span>
<span class="sd">        Default is None.</span>
<span class="sd">    :return: Tuple containing a dictionary containing GKS VA frequency information,</span>
<span class="sd">        (split by ancestry groups and sex if desired) for the specified variant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Throw warnings if contradictory arguments passed.</span>
    <span class="k">if</span> <span class="n">by_sex</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ancestry_groups</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Splitting whole database by sex is not yet supported. If using &#39;by_sex&#39;,&quot;</span>
            <span class="s2">&quot; please also specify &#39;ancestry_groups&#39; to stratify by.&quot;</span>
        <span class="p">)</span>

    <span class="n">contig</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">gnomad_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">contig</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">ref</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Define function to return a frequency report dictionary for a given group</span>
    <span class="k">def</span> <span class="nf">_create_group_dicts</span><span class="p">(</span>
        <span class="n">group_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">group_label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">group_sex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a dictionary containing the frequency information of a given variant for a given group.</span>

<span class="sd">        :param group_index: Index of frequency within the &#39;freq&#39; annotation for the desired group.</span>
<span class="sd">        :param group_id: String containing variant, genetic ancestry group, and sex (if requested).</span>
<span class="sd">            - Example: &quot;chr19-41094895-C-T.afr.XX&quot;.</span>
<span class="sd">        :param group_label: String containing the full name of genetic ancestry group requested.</span>
<span class="sd">            - Example: &quot;African/African American&quot;.</span>
<span class="sd">        :param group_sex: String indicating the sex of the group.</span>
<span class="sd">            - Example: &quot;XX&quot; or &quot;XY&quot;.</span>
<span class="sd">        :return: Dictionary containing variant frequency information,</span>
<span class="sd">            - (by genetic ancestry group and sex if desired) for specified variant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Obtain frequency information for the specified variant.</span>
        <span class="n">group_freq</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">group_index</span><span class="p">]</span>

        <span class="c1"># Cohort characteristics.</span>
        <span class="n">characteristics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">characteristics</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;genetic ancestry&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">group_label</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">group_sex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">characteristics</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;biological sex&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">group_sex</span><span class="p">})</span>

        <span class="c1"># Dictionary to be returned containing information for a specified group.</span>
        <span class="n">freq_record</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">group_id</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;CohortAlleleFrequency&quot;</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_label</span><span class="si">}</span><span class="s2"> Cohort Allele Frequency for </span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;focusAllele&quot;</span><span class="p">:</span> <span class="s2">&quot;#/focusAllele&quot;</span><span class="p">,</span>
            <span class="s2">&quot;focusAlleleCount&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">],</span>
            <span class="s2">&quot;locusAlleleCount&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">],</span>
            <span class="s2">&quot;alleleFrequency&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">],</span>
            <span class="s2">&quot;cohort&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">group_id</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s2">&quot;characteristics&quot;</span><span class="p">:</span> <span class="n">characteristics</span><span class="p">},</span>
            <span class="s2">&quot;ancillaryResults&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;homozygotes&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;homozygote_count&quot;</span><span class="p">]},</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">freq_record</span>

    <span class="c1"># Create a list to then add the dictionaries for frequency reports for</span>
    <span class="c1"># different ancestry groups to.</span>
    <span class="n">list_of_group_info_dicts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through provided groups and generate dictionaries.</span>
    <span class="k">if</span> <span class="n">ancestry_groups</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ancestry_groups</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">-adj&quot;</span>
            <span class="n">index_value</span> <span class="o">=</span> <span class="n">freq_index_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">group_result</span> <span class="o">=</span> <span class="n">_create_group_dicts</span><span class="p">(</span>
                <span class="n">group_index</span><span class="o">=</span><span class="n">index_value</span><span class="p">,</span>
                <span class="n">group_id</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                <span class="n">group_label</span><span class="o">=</span><span class="n">ancestry_groups_dict</span><span class="p">[</span><span class="n">group</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># If specified, stratify group information by sex.</span>
            <span class="k">if</span> <span class="n">by_sex</span><span class="p">:</span>
                <span class="n">sex_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">]:</span>
                    <span class="n">sex_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">sex</span><span class="si">}</span><span class="s2">-adj&quot;</span>
                    <span class="n">sex_index_value</span> <span class="o">=</span> <span class="n">freq_index_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sex_key</span><span class="p">)</span>
                    <span class="n">sex_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">sex</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">sex_result</span> <span class="o">=</span> <span class="n">_create_group_dicts</span><span class="p">(</span>
                        <span class="n">group_index</span><span class="o">=</span><span class="n">sex_index_value</span><span class="p">,</span>
                        <span class="n">group_id</span><span class="o">=</span><span class="n">sex_id</span><span class="p">,</span>
                        <span class="n">group_label</span><span class="o">=</span><span class="n">ancestry_groups_dict</span><span class="p">[</span><span class="n">group</span><span class="p">],</span>
                        <span class="n">group_sex</span><span class="o">=</span><span class="n">sex</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">sex_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sex_result</span><span class="p">)</span>

                <span class="n">group_result</span><span class="p">[</span><span class="s2">&quot;subcohortFrequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sex_list</span>

            <span class="n">list_of_group_info_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_result</span><span class="p">)</span>

    <span class="c1"># Add overall frequency, via label &#39;adj&#39; which is currently stored at</span>
    <span class="c1"># position #1 (index 0).</span>
    <span class="n">overall_freq</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Create final dictionary to be returned.</span>
    <span class="n">final_freq_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;CohortAlleleFrequency&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Overall Cohort Allele Frequency for </span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derivedFrom&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;DataSet&quot;</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}</span><span class="s2"> v</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;focusAllele&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="s2">&quot;&quot;</span>
        <span class="p">),</span>  <span class="c1"># Information can be populated with the result of add_gks_vrs()</span>
        <span class="s2">&quot;focusAlleleCount&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">],</span>
        <span class="s2">&quot;locusAlleleCount&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">],</span>
        <span class="s2">&quot;alleleFrequency&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">],</span>
        <span class="s2">&quot;cohort&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;ALL&quot;</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="c1"># Create ancillaryResults for additional frequency and popMaxFAF95 information</span>
    <span class="n">ancillaryResults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;homozygotes&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;homozygote_count&quot;</span><span class="p">],</span>
        <span class="s2">&quot;popMaxFAF95&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">faf95</span><span class="o">.</span><span class="n">popmax</span><span class="p">,</span>
            <span class="s2">&quot;confidenceInterval&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">faf95</span><span class="o">.</span><span class="n">popmax_population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;popMaxFAF95&quot;</span><span class="p">][</span>
            <span class="s2">&quot;popFreqID&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">input_struct</span><span class="o">.</span><span class="n">faf95</span><span class="o">.</span><span class="n">popmax_population</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;popMaxFAF95&quot;</span><span class="p">][</span><span class="s2">&quot;popFreqID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Add mean coverage depth statistics if the input was annotated</span>
    <span class="c1"># with coverage information.</span>
    <span class="k">if</span> <span class="s2">&quot;mean_depth&quot;</span> <span class="ow">in</span> <span class="n">input_struct</span><span class="p">:</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;meanDepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">mean_depth</span>

    <span class="n">final_freq_dict</span><span class="p">[</span><span class="s2">&quot;ancillaryResults&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancillaryResults</span>

    <span class="c1"># If ancestry_groups were passed, add the ancestry group dictionary to the</span>
    <span class="c1"># final frequency dictionary to be returned.</span>
    <span class="k">if</span> <span class="n">ancestry_groups</span><span class="p">:</span>
        <span class="n">final_freq_dict</span><span class="p">[</span><span class="s2">&quot;subcohortFrequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_of_group_info_dicts</span>

    <span class="k">return</span> <span class="n">final_freq_dict</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>